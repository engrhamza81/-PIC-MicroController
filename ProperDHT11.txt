// PIC18F46K20 Configuration Bit Settings

// CONFIG1H
#pragma config FOSC = HS        // Oscillator Selection bits (HS oscillator)
#pragma config FCMEN = OFF      // Fail-Safe Clock Monitor disabled
#pragma config IESO = OFF       // Oscillator Switchover mode disabled

// CONFIG2L
#pragma config PWRTEN = ON      // Power-up Timer enabled
#pragma config BOREN = OFF      // Brown-out Reset disabled
#pragma config BORV = 18        // Brown-out Reset Voltage set to 1.8V nominal

// CONFIG2H
#pragma config WDTEN = OFF      // Watchdog Timer controlled by SWDTEN bit
#pragma config WDTPS = 32768    // Watchdog Timer Postscale 1:32768

// CONFIG3H
#pragma config CCP2MX = PORTC   // CCP2 multiplexed with RC1
#pragma config PBADEN = ON      // PORTB<4:0> as analog inputs on reset
#pragma config LPT1OSC = OFF    // Timer1 in higher power operation
#pragma config HFOFST = ON      // HFINTOSC starts CPU without delay
#pragma config MCLRE = OFF      // MCLR disabled; RE3 as input

// CONFIG4L
#pragma config STVREN = OFF     // Stack Overflow/Underflow Reset disabled
#pragma config LVP = OFF        // Single-Supply ICSP disabled
#pragma config XINST = OFF      // Extended Instruction Set disabled

// CONFIG5L
#pragma config CP0 = OFF        // Code Protection Block 0 disabled
#pragma config CP1 = OFF        // Code Protection Block 1 disabled
#pragma config CP2 = OFF        // Code Protection Block 2 disabled
#pragma config CP3 = OFF        // Code Protection Block 3 disabled

// CONFIG5H
#pragma config CPB = OFF        // Boot Block Code Protection disabled
#pragma config CPD = OFF        // Data EEPROM Code Protection disabled

// CONFIG6L
#pragma config WRT0 = OFF       // Write Protection Block 0 disabled
#pragma config WRT1 = OFF       // Write Protection Block 1 disabled
#pragma config WRT2 = OFF       // Write Protection Block 2 disabled
#pragma config WRT3 = OFF       // Write Protection Block 3 disabled

// CONFIG6H
#pragma config WRTC = OFF       // Config registers write protection disabled
#pragma config WRTB = OFF       // Boot Block write protection disabled
#pragma config WRTD = OFF       // EEPROM write protection disabled

// CONFIG7L
#pragma config EBTR0 = OFF      // Table Read Protection Block 0 disabled
#pragma config EBTR1 = OFF      // Table Read Protection Block 1 disabled
#pragma config EBTR2 = OFF      // Table Read Protection Block 2 disabled
#pragma config EBTR3 = OFF      // Table Read Protection Block 3 disabled

// CONFIG7H
#pragma config EBTRB = OFF      // Boot Block Table Read Protection disabled


#include <xc.h>
#include <stdio.h>
#include <string.h>

// Configuration Bits


#define _XTAL_FREQ 4000000      // 4 MHz oscillator frequency

// DHT11 sensor connection (data pin connected to RB0)
#define DHT11_PIN      PORTBbits.RB0
#define DHT11_PIN_DIR  TRISBbits.TRISB0
#define DHT11_PIN_LAT  LATBbits.LATB0

// Global variables
unsigned char T_Byte1, T_Byte2, RH_Byte1, RH_Byte2, CheckSum;

// Function to initialize UART
void UART_Init(void) {
    TRISC6 = 0;     // TX pin (RC6) as output
    TRISC7 = 1;     // RX pin (RC7) as input
    SPBRG = 25;     // Baud rate 9600 for 4MHz with BRGH = 1
    BRGH = 1;       // High-speed
    SYNC = 0;       // Asynchronous mode
    SPEN = 1;       // Enable serial port (TX/ RX)
    TXEN = 1;       // Enable transmitter
}

// Function to transmit a single character via UART
void UART_TxChar(char ch) {
    while(!TXIF);   // Wait until buffer is empty
    TXREG = ch;     // Transmit character
}

// Function to transmit a string via UART
void UART_TxString(const char* str) {
    while(*str) {
        UART_TxChar(*str++);
    }
}

// Function to send start signal to DHT11 sensor
void Start_Signal(void) {
    DHT11_PIN_DIR = 0;     // Configure DHT11_PIN as output
    DHT11_PIN_LAT = 0;     // Pull DHT11_PIN low
    __delay_ms(20);        // Wait for at least 18ms
    DHT11_PIN_LAT = 1;     // Pull DHT11_PIN high
    __delay_us(30);        // Wait for 20-40us
    DHT11_PIN_DIR = 1;     // Configure DHT11_PIN as input
}

// Function to check response from DHT11 sensor
unsigned char Check_Response(void) {
    unsigned int timeout = 0;

    // Wait for DHT11 to pull the line low (response start)
    while(DHT11_PIN) {
        __delay_us(1);
        if (++timeout > 100) return 0; // Timeout
    }

    timeout = 0;
    // Wait for DHT11 to pull the line high (response end)
    while(!DHT11_PIN) {
        __delay_us(1);
        if (++timeout > 100) return 0; // Timeout
    }

    timeout = 0;
    // Wait for DHT11 to pull the line low (data transmission start)
    while(DHT11_PIN) {
        __delay_us(1);
        if (++timeout > 100) return 0; // Timeout
    }

    return 1; // Response OK
}

// Function to read one byte from DHT11 sensor
unsigned char Read_Data(void) {
    unsigned char i, data = 0;
    for(i = 0; i < 8; i++) {
        unsigned int timeout = 0;

        // Wait for the start of the bit (DHT11 pulls line high)
        while(!DHT11_PIN) {
            __delay_us(1);
            if (++timeout > 100) break; // Timeout
        }

        __delay_us(30); // Wait for 30us

        if(DHT11_PIN)
            data |= (1 << (7 - i)); // If line is still high, it's a '1'

        timeout = 0;
        // Wait for the end of the bit (DHT11 pulls line low)
        while(DHT11_PIN) {
            __delay_us(1);
            if (++timeout > 100) break; // Timeout
        }
    }
    return data;
}

void main(void) {
    // Oscillator configuration
    OSCCON = 0x60;       // Set internal oscillator to 4MHz

    // Configure all PORTB pins as digital
    ADCON1 = 0x0F;

    // Initialize UART
    UART_Init();

    // Main loop
    while(1) {
        Start_Signal(); // Send start signal to DHT11

        if(Check_Response()) { // Check for response
            // Read 5 bytes from DHT11
            RH_Byte1 = Read_Data();
            RH_Byte2 = Read_Data();
            T_Byte1 = Read_Data();
            T_Byte2 = Read_Data();
            CheckSum = Read_Data();

            // Verify checksum
            if(CheckSum == (RH_Byte1 + RH_Byte2 + T_Byte1 + T_Byte2)) {
                char buffer[20];
                sprintf(buffer, "Temp: %d C\r\n", T_Byte1);
                UART_TxString(buffer);
            } else {
                UART_TxString("Checksum Error\r\n");
            }
        } else {
            UART_TxString("No DHT11 Response\r\n");
        }

        __delay_ms(2000); // Wait for 2 seconds before next reading
    }
}
